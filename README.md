# コンピュータシステムの理論と実装 第12章 - OS

「The Elements of Computing Systems」(Nand2Tetris) 第12章の学習記録

## 2進数での算術演算

コンピュータは複雑な演算を、**シンプルな操作の組み合わせ** で実現している。

### 基本原理：シフト演算

| 演算 | 意味 | 例 |
|------|------|-----|
| 左に1シフト | ×2 | 6 (`110`) → 12 (`1100`) |
| 左に2シフト | ×4 | 6 (`110`) → 24 (`11000`) |
| 右に1シフト | ÷2 | 12 (`1100`) → 6 (`110`) |

10進数で左に1桁ずらすと×10になるのと同じ原理。

---

## 乗算（Shift-and-Add アルゴリズム）

**原理**: 乗算は「加算」と「シフト」だけで実現できる

### なぜ可能か

2進数の各桁は0か1のみ。掛ける数を2進数で分解すると：

```
12 × 10 = 12 × (8 + 2)
        = 12 × 8 + 12 × 2
        = 96 + 24
        = 120
```

- `× 8` は左に3シフト
- `× 2` は左に1シフト

つまり「掛け算」が「シフトと足し算」に変換される。

### アルゴリズム

```
multiply(x, y):
    sum = 0
    shiftedX = x
    for i = 0 to n-1:
        if (yのi番目ビットが1):
            sum = sum + shiftedX
        shiftedX = shiftedX << 1  // 左シフト（×2）
    return sum
```

### 具体例: 12 × 10 = 120

```
x = 12 (1100)
y = 10 (1010)
```

| i | yのiビット目 | shiftedX | 加算? | sum |
|---|-------------|----------|-------|-----|
| 0 | 0 | 12 | ✗ | 0 |
| 1 | 1 | 24 | ✓ | 0 + 24 = 24 |
| 2 | 0 | 48 | ✗ | 24 |
| 3 | 1 | 96 | ✓ | 24 + 96 = 120 |

**結果: 120**

### 筆算形式

```
        1100   (12)
      × 1010   (10)
      ------
        0000   ← ビット0が0: 足さない
       1100    ← ビット1が1: 12を左に1シフト = 24
      0000     ← ビット2が0: 足さない
     1100      ← ビット3が1: 12を左に3シフト = 96
    --------
     1111000   (120)
```

---

## 除算（長除法）

**原理**: 除算は「引き算」と「シフト」と「比較」だけで実現できる

### 10進数の筆算と同じ

2進数の除算は、小学校で習った筆算の割り算とまったく同じ方法。

**7 ÷ 2 = 3 余り1** の例（7 = `111`, 2 = `10`）：

```
        0 1 1  ← 商（= 3）
      -------
  10 ) 1 1 1
```

| 見ている値 | 10進数 | 質問 | 答え | 商 |
|-----------|--------|------|------|-----|
| 1 | 1 | 「1の中に2は入る？」 | 入らない | 0 |
| 11 | 3 | 「3の中に2は入る？」 | 1回入る | 1 |
| 残り11 | 3 | 「3の中に2は入る？」 | 1回入る | 1 |

商 = `011` = 3, 余り = 1

### 10進数と2進数の違い

| | 10進数 | 2進数 |
|--|--------|-------|
| 商の各桁 | 0〜9 | 0か1だけ |
| 判断 | 「何回入る？」 | 「入る？入らない？」 |

2進数は Yes/No だけなので、実はもっと単純。

### シフトによる効率化

単純に引くと遅い（30 ÷ 4 で7回の引き算）。
除数を左シフト（2倍）して大きくしてから引くと速い（3回で済む）：

```
30 ÷ 4 を計算

4 を左シフトしていく:
  4 → 8 → 16 → 32（30を超えた！）

大きい方から引く:
  30 - 16 = 14  → 商に 4 (16 = 4×4)
  14 - 8 = 6    → 商に 2 (8 = 4×2)
  6 - 4 = 2     → 商に 1 (4 = 4×1)

商 = 4 + 2 + 1 = 7
```

### 再帰的アルゴリズム

```
divide(x, y):
    if y > x: return 0
    q = divide(x, 2*y)      // 除数を2倍して再帰
    if (x - 2*q*y) < y:
        return 2*q
    else:
        return 2*q + 1
```

---

## 平方根

二分探索で、上位ビットから順に「このビットを立てても二乗がxを超えないか」を確認。

```
sqrt(x):
    y = 0
    for j = n/2 - 1 downto 0:
        if (y + 2^j)² <= x:
            y = y + 2^j
    return y
```

---

## 学びのポイント

1. **複雑なものは単純なものの組み合わせ** - 乗算器がなくても、加算器とシフト回路で乗算ができる
2. **2進数の特性を活かす** - 各桁が0か1なので、条件分岐が単純になる
3. **Nand2Tetrisの哲学** - NANDゲートから始めて、テトリスが動くコンピュータを作る

---

## 参考

- 原著: [The Elements of Computing Systems, 2nd Edition](https://mitpress.mit.edu/9780262539807/)
- 日本語版: [コンピュータシステムの理論と実装 第2版](https://www.oreilly.co.jp/books/9784814400874/)
